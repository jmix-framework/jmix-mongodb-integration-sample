:sample-project: jmix-mongodb-datastore-sample

= MongoDB Integration in Jmix

This guide demonstrates how to integrate MongoDB as an additional database within a Jmix application. MongoDB, a popular NoSQL database, allows for flexible and scalable data storage. In this guide, you’ll configure MongoDB to manage `VisitLog` entries associated with Jmix `Visit` entities. We’ll leverage Spring Data MongoDB within Jmix to handle CRUD operations for `VisitLog` entries, creating a logbook structure while keeping the data model and UI logic separate.


[[requirements]]
== Requirements

If you want to implement this guide step by step, you will need the following:

1. xref:ROOT:setup.adoc[Setup Jmix Studio]
2. Download the sample project. You can **download the completed sample project**, which includes all the examples used in this guide. This allows you to explore the finished implementation and experiment with the functionality right away.
* https://github.com/jmix-framework/{sample-project}/archive/refs/heads/main.zip[Download^] and unzip the source repository
* or clone it using git:
`git clone https://github.com/jmix-framework/{sample-project}.git`

Alternatively, you can **start with the base Petclinic project** and follow the step-by-step instructions in this guide to implement the features yourself: https://github.com/jmix-framework/jmix-petclinic-2[Jmix Petclinic] and follow along to add the functionality step-by-step.

[[what-we-are-going-to-build]]
== What We are Going to Build

In this guide, we enhance the https://github.com/jmix-framework/jmix-petclinic-2[Jmix Petclinic^] by integrating MongoDB to store `VisitLog` entries that detail specific interactions within the application. This MongoDB setup allows us to manage visit logs independently of the Jmix persistence context, ensuring a separation between core Jmix entities and log data.

The final application will include:

- **MongoDB Integration**: Setting up MongoDB to store visit log data.
- **Entity Layer**: Differentiating between persistent entities and UI-facing DTOs.
- **Service Layer**: Converting between MongoDB entities and Jmix DTOs, while managing CRUD operations.
- **UI Integration**: Displaying and managing `VisitLog` entries via Jmix UI components, with full CRUD support.

[[final-application]]
=== Final Application

video::zTYx_KSeMzY[youtube,width=1280,height=600]

[[integration-approaches]]
== Integration Approaches

In Jmix applications, MongoDB can be integrated as an additional data source using one of two main approaches:

1. **UI Data Components with Custom Delegates**: In this approach, MongoDB is accessed independently via standard UI Data Components, which are configured with custom `LoadDelegate` and `SaveDelegate` methods. These delegates direct CRUD operations to a MongoDB service layer, simplifying integration for specific use cases. However, this setup bypasses generic Jmix features like security and the Generic Filter component.

2. **Implementing the Jmix Datastore API**: Jmix’s `DataStore` API allows MongoDB to integrate directly with the Jmix Data Manager, embedding MongoDB entities into the Jmix persistence context. This approach supports high-level features such as the security system and the Generic Filter component but requires a more complex setup, suitable for core integrations.

In this guide, we focus on using UI Data Components with Custom Delegates, keeping MongoDB interactions separate from the Jmix Data Manager while enabling straightforward integration for specific application needs.

[[mongodb-setup]]
== MongoDB Setup

Before configuring the Jmix application, set up MongoDB as a prerequisite. In this example, we use Docker Compose to simplify the setup, which is ideal for local development environments. Docker Compose allows MongoDB to be quickly deployed, and we include Mongo Express as an optional, web-based interface for directly managing MongoDB data.

Create a `docker-compose.yml` file with the following configuration:

.docker-compose.yml
[source,yml,indent=0]
----
include::example$/docker-compose.yml[]
----

This configuration starts two services:
- **MongoDB** for data storage, accessible on port `27017`.
- **Mongo Express** for a UI to manage MongoDB data, accessible on port `8081`.

To launch MongoDB and Mongo Express, run:

[source,bash,indent=0]
----
$ docker compose up
----

Once started, Mongo Express can be accessed at `http://localhost:8081`, where you can view and manage MongoDB collections and data directly.

With MongoDB running, proceed to configure the Jmix application to connect to the database.

[[adding-dependencies]]
== Adding Dependencies

To integrate MongoDB with Jmix, add the `spring-boot-starter-data-mongodb` dependency to your `build.gradle` file:

.build.gradle
[source,groovy]
----
include::example$/build.gradle[tags=gradle-dependencies;mongodb-dependency]
----

The `spring-boot-starter-data-mongodb` is part of the Spring Data project, managed and supported directly by the Spring team. It is the standard solution for integrating MongoDB within Spring applications, providing Spring Data repositories, MongoDB-specific annotations, and utilities. This starter simplifies interactions with MongoDB and is fully compatible with Spring Boot.

The version of `spring-boot-starter-data-mongodb` aligns automatically with the compatible Spring Boot version, as defined by the Jmix BOM (Bill of Materials). This setup ensures compatibility and minimizes manual dependency management.

[[mongodb-configuration]]
== MongoDB Configuration

In your Jmix application, configure the MongoDB connection URI in `application.properties`. Use the credentials defined in the Docker Compose setup:

.application.properties
[source,properties]
----
spring.data.mongodb.uri=mongodb://root:petclinic@localhost:27017/petclinic?authSource=admin
----

This configuration directs Jmix to connect to MongoDB for managing `VisitLog` entities or other collections, using the correct credentials and database specified in the URI.

We will now examine each layer in detail, from database access and the service layer to the UI views.


[[creating-visitlog-entity]]
== Creating a VisitLog Entity

In this application, the persistence and presentation layers are separated by using two distinct classes:

* **VisitLog**: A DTO entity used in the UI for managing and displaying visit log data.
* **VisitLogDocument**: A dedicated persistence entity mapped to MongoDB for storing and retrieving visit logs.

This separation enhances the application structure by isolating persistence details from the UI layer, ensuring a clear division of responsibilities.

[[dto-entity]]
=== DTO Entity

The `VisitLog` entity is used in the Jmix UI for displaying and managing visit log data. As a xref:data-model:entities.adoc#dto[DTO entity], it does not interact directly with MongoDB but serves as a data model tailored for UI components.

In this UI representation, `VisitLog` includes a direct reference to the `Visit` entity from the relational database. This is possible because `VisitLog` is only used in the UI layer. When data is converted to its persistent form for MongoDB, we store only the UUID of the associated `Visit`. Since a true foreign key relationship cannot exist between multiple databases, we store the identifier as a simple reference.

.VisitLog.java
[source,java,indent=0]
----
include::example$src/main/java/io/jmix/petclinic/visit/log/VisitLog.java[tags=imports;visit-log-entity;closing-class]
----

[[mongodb-document]]
=== MongoDB Document

The `VisitLogDocument` class is annotated with `@Document`, mapping it to a MongoDB collection. This class is the persistent representation of `VisitLog`, and it is used exclusively in the service layer to interact with MongoDB.

.VisitLogDocument.java
[source,java,indent=0]
----
include::example$src/main/java/io/jmix/petclinic/visit/log/VisitLogDocument.java[tags=imports;visit-log-document;closing-class]
----
<1> `@Document` - Marks this class as a MongoDB document, treating `VisitLogDocument` as a collection in MongoDB. This annotation is specific to non-relational databases and replaces `@Entity`.
<2> `@Id` - Defines the unique identifier field for each document in the MongoDB collection, functioning similarly to a primary key.
<3> `visitId` - Stores the UUID of the associated `Visit` entry as a String.

The `VisitLogService` class manages data conversions between `VisitLog` and `VisitLogDocument`, maintaining a clean separation of concerns between persistence and presentation layers.

[[spring-data-repository]]
== Spring Data Repository

Next, let's take a look at how to access the database. We use a Spring Data repository from the above dependency `spring-boot-starter-data-mongodb`. Spring Data provides an abstraction layer specifically designed for data access, taking care of standard CRUD operations and making data interactions simpler and more efficient.

Using Spring Data is an alternative to the `DataManager` commonly used in Jmix. The idea is to define an interface that automatically includes standard CRUD methods, allowing you to declare custom methods within the interface, which Spring Data then implements automatically.

.VisitLogDocumentRepository.java
[source,java,indent=0]
----
include::example$src/main/java/io/jmix/petclinic/visit/log/VisitLogDocumentRepository.java[tags=imports;repository]
----

This repository interface inherits CRUD operations like `save`, `findById`, `findAll`, and `deleteById` from `MongoRepository`, allowing standard data access without requiring additional implementation. It also includes a custom query method:

* `findByVisitId(String visitId)`: Retrieves a list of `VisitLogDocument` entities associated with a specific `visitId`. Spring Data MongoDB automatically generates the query for this method based on its naming convention, making it easy to add custom finder methods.

For more details on MongoDB repositories and custom query methods, refer to the Spring Data MongoDB repository documentation: https://docs.spring.io/spring-data/mongodb/reference/mongodb/repositories/repositories.html[Spring Data MongoDB repository documentation^].

TIP: By the way, Spring Data repositories aren’t just limited to MongoDB or other non-relational databases; you can also use them for regular relational database interactions in Jmix. This provides an alternative to the `DataManager` API and can be a convenient option in business logic code when Spring Data’s approach feels like a better fit. For more details on using Spring Data repositories in Jmix, see:
xref:data-access:data-repositories.adoc[].

[[visit-log-service]]
== Service Layer for Visit Logs

After defining the repository, we can now use it within the service layer. While the repository handles only database access, the service layer takes on additional responsibilities, including business logic, data transformations, and providing a UI-friendly API.

In our example, `VisitLogService` links the UI and MongoDB by converting `VisitLog` entries between their UI format (`VisitLog`) and persistent structure (`VisitLogDocument`). This setup lets the UI interact with an easy-to-use DTO while ensuring data is correctly stored and retrieved in MongoDB.

Let's take a look at how the conversion from the Document to the DTO entity works, by reviewing the method to find all `VisitLog` entities for a given `Visit`:

.VisitLogService.java
[source,java,indent=0]
----
include::example$src/main/java/io/jmix/petclinic/visit/log/VisitLogService.java[tags=class;to-visit-log]
----

In `VisitLogService`, we use `VisitLogDocumentRepository` to retrieve `VisitLog` entries from MongoDB.

The `findByVisit()` method fetches entries associated with a given `Visit` and converts them into `VisitLog` DTOs through `toVisitLog()`. During this conversion, `DataManager` resolves the `Visit` reference, and `EntityStates` marks the DTO as non-new.


[[ui-integration-with-jmix]]
== UI Integration with Jmix

Now that we have `VisitLogService` set up, we can use it in the UI to handle `VisitLog` data associated with specific visits.

In both the list and detail views, we use `DataContext` delegates to customize how Jmix accesses data. Where Jmix would normally interact with a relational database, we use custom implementations with calls to `VisitLogService` instead.

[[visit-log-list-view]]
=== Visit Log List View

The `VisitLogListView` provides a data grid view where users can:

1. View a list of `VisitLog` entries related to a specific `Visit`.
2. Create new `VisitLog` entries, with the current `Visit` reference automatically associated.
3. Remove selected `VisitLog` entries.

This list view displays all `VisitLog` entries associated with a `Visit` and uses `VisitLogService` to handle CRUD operations.

.VisitLogListView.java
[source,java,indent=0]
----
include::example$src/main/java/io/jmix/petclinic/view/visitlog/VisitLogListView.java[]
----

[[visit-log-detail-view]]
=== Visit Log Detail View

The `VisitLogDetailView` allows users to view and edit details for a selected `VisitLog` entry associated with a specific `Visit`. This view uses `VisitLogService` to handle the loading and saving of `VisitLog` entities.

The `VisitLogDetailView` includes essential methods for managing `VisitLog` entries and interacts with MongoDB via `VisitLogService`.

.VisitLogDetailView.java
[source,java,indent=0]
----
include::example$src/main/java/io/jmix/petclinic/view/visitlog/VisitLogDetailView.java[]
----

[[summary]]
== Summary


[[further-information]]
=== Further Information
* https://docs.spring.io/spring-data/mongodb/reference/mongodb/repositories/repositories.html[Spring Data MongoDB repository documentation^]